# Pytest-BDD
Тестовое задание
Обзор
Этот проект представляет собой пример тестирования пользовательского интерфейса с помощью Selenium WebDriver, написанного на Python, с использованием шаблона дизайна объектной модели страницы и управляемого с помощью файлов функций BDD через Pytest BDD. Он может быть использован для запуска тестирования других пользовательских интерфейсов с минимальными изменениями в проекте.

1. Написать тест-кейс при помощи Gherkin:
a. Открыть браузер и развернуть на весь экран.
b. Зайти на yandex.ru
c. В разделе «Маркет» выбрать «Смартфоны».
d. Перейти в «Все фильтры».
e. Задать параметр поиска до 20000 рублей и Диагональ экрана от 3 дюймов.
f. Выбрать не менее 5 любых производителей.
g. Нажать кнопку «Показать».
h. Посчитать кол-во смартфонов на одной странице.
i. Запомнить последний из списка.
j. Изменить Сортировку на другую (по цене/ по рейтингу/ по скидке).
k. Найти и нажать по имени запомненного объекта.
l. Вывести рейтинг выбранного товара.
m. Закрыть браузер.


# # Зачем использовать Selenium?
Selenium - это платформа с открытым исходным кодом для тестирования веб-приложений, которая, вероятно, де-факто является структурой, о которой большинство людей думают, когда речь заходит о тестировании пользовательского интерфейса. Он поддерживает множество браузеров (Chrome, Firefox, Safari, IE/Edge), а также все основные языки (есть привязки для Java, Python, JavaScript, C # и Ruby), что делает его подходящим практически для любого проекта тестирования пользовательского интерфейса. Он также очень портативен, поэтому работает в ОС Windows, macOS и Linux/Unix, и, конечно, открытый исходный код является бесплатным. Существует обширное и активное сообщество Selenium, предлагающее поддержку для пользователей и помогающее расширять и развивать Selenium, что всегда является бонусом.


# # Тестируемое веб-приложение
Веб-сайт, который тестируется этой структурой, является «Yandex market», сторонним приложением, которое содержит ряд различных страниц, каждая из которых демонстрирует различные аспекты тестирования пользовательского интерфейса, и проблемы, с которыми можно столкнуться при реализации такого тестирования. О

# # Тестовый фреймворк
Как указано выше, этот проект содержит тестовую структуру Selenium Python, реализует шаблон проектирования объектной модели страницы и использует BDD Pytest. Таким образом, она соответствует передовым практикам автоматизации тестирования. Объектная модель страницы означает, что каждая отдельная веб-страница имеет свой собственный класс, каждый из которых содержит методы, специфичные для элементов управления на этой странице. Таким образом, каждая страница является независимой и отдельной от тестов, что означает, что любые изменения страницы изолированы только для соответствующего класса страницы. Это делает код более чистым, простым в чтении и обслуживании и содержит меньше дубликатов. Использование БДД в стиле Геркина означает, что сами тесты также чисты и понятны, написаны на простом английском языке, поэтому их может понять любой человек, работающий с проектом, включая нетехнические роли. Хотя этот проект является лишь примером того, как настроить Selenium для тестирования пользовательского интерфейса в Python, в реальном проекте использование BDD необходимо для сотрудничества между QA, разработчиками и бизнес-ролями (например, владельцами продуктов, бизнес-аналитиками и т.д.). Качество является обязанностью каждого, что означает, что сами тесты должны быть легко поняты всеми заинтересованными сторонами.

# # # Технический стек
Python (>=3.8)

pytest (v6.2.4)

pytest_bdd (v4.0.2)

selenium

webdriver-manager


# # # Структура проекта
Проект использует стандартную структуру и соглашение об именовании (надеюсь):
* 'features' - эта папка содержит файлы Gherkin '.feature', по одному на страницу веб-сайта. Разделяя тесты для каждой страницы на отдельные файлы функций, мы продолжаем тему «Объектная модель страницы» независимости страницы и упрощаем расширение структуры в будущем. Каждому файлу функций присваивается имя после страницы, которую он тестирует.
* 'pages' - реализация объектной модели страницы для отдельных страниц веб-сайта, по одному файлу класса на страницу. Каждый класс именуется в честь соответствующей страницы, например, «StartPage», «DropderPage» и т.д. Существует также «BasePage», который другие классы страниц реализуют/расширяют посредством наследования.
* 'step _ defs' - совокупность файлов, содержащих реализацию шагов из файлов функций BDD. Как указано выше, на каждую страницу имеется один файл шагов, каждый из которых имеет имя после тестируемой страницы, например, «test _ dynamic _ controls _ page _ steps.py». Имя файла начинается с «test _», так как проект использует Pytest, и этот префикс необходим для того, чтобы Pytest распознал этот файл как тестовый файл (с Pytest/Pytest BDD - это файлы шагов, а не функции, которые выполняются, поскольку каждый файл шагов привязан к файлу функций с помощью ключевого слова «сценарии» - см. [Running tests] (# running-tests)).
* 'config.json' - объект JSON, используемый для определения определенных опций конфигурации, например браузера, запуска без заголовка и неявного тайм-аута ожидания.
* 'conftest.py' - Этот файл содержит методы настройки браузера (с учетом требуемых параметров из файла «config.json») и предоставления доступа к ним методам страницы. Также, в этом файле содержатся шаги, общие для нескольких файлов функций.

# # # Классы объектной модели страницы
Как отмечалось выше, папка «pages» содержит соответствующие классы объектной модели страницы для каждой проверенной страницы. Каждый класс страницы, включая абстрактный класс BasePage, следует одному и тому же шаблону:
* кортежи селектора/локатора, объявленные как пары, причем первый элемент является методом локатора («By.ID», «By.XPATH» и т.д.), а второй элемент является самим локатором (т.е. идентификатором, xpath и т.д.).
* методы взаимодействия, например, щелчок по элементу, получение текста элемента и т.д. Эти методы используют вышеупомянутые кортежи локатора, передавая их вызовам «find _ element» или «find _ elements».

Таким образом мы инкапсулируем сами веб-элементы, допуская только те взаимодействия, которые были реализованы с помощью наших методов, гарантируя, что тесты (по сути, пользователь) могут взаимодействовать с веб-страницей только известными способами.

Класс «BasePage» определяет константы URL для каждой страницы, обеспечивая их доступность для методов в каждом отдельном классе страниц. Также в базовом классе объявлены некоторые общие локаторы для элементов, используемых на нескольких страницах, чтобы избежать необходимости объявлять локатор в каждом классе страниц (следуя принципу DRY). Методы взаимодействия для верхнего и нижнего колонтитулов страницы также объявляются в классе BasePage, чтобы уменьшить дублирование кода. Чтобы обойти тот факт, что элемент заголовка на проверенных страницах не использует непротиворечивый тег или класс HTML, в классе BasePage объявляется абстрактный метод get _ page _ title _ text, обеспечивающий реализацию каждым отдельным классом страницы метода для получения текста заголовка страницы, использование локатора «» PAGE _ TITLE «», специфичного для HTML-кода этой страницы.

# # # Поддерживаемые браузеры
Модуль «conftest.py» использует зависимость Webdriver-Manager для управления различными драйверами браузера. Прибор «browser» Pytest возвращает соответствующий экземпляр WebDriver для выбранного браузера с поддержкой:
* Chrome - опция по умолчанию
* Firefox

Используемый браузер может быть передан через параметр командной строки Pytest с ключом «browser», по умолчанию в Chrome, если такое свойство не указано. Кроме того, параметр «browser» можно настроить с помощью файла «config.json».

Свойство 'headless' используется для определения того, должен ли браузер работать в безголовом режиме. Браузеры без заголовков, как правило, работают быстрее и потребляют меньше ресурсов, так как они фактически не визуализируют веб-страницы, поэтому при выполнении автоматизированных тестов пользовательского интерфейса предпочтительнее. Однако при отладке тестов пользовательского интерфейса часто проще установить для этого флага значение false, т.е. запустить «head», чтобы легче было идентифицировать проблемы с тестами. «headless» по умолчанию верно, но может быть изменено в файле «config.json»; на данном этапе он не был включен в качестве параметра командной строки.

Плагин Webdriver-Manager также поддерживает Edge, Opera и Internet Explorer, но я не включил эти параметры в этом проекте на данном этапе.
# # # Работа с проектом

Склонировать себе репозитарий
```
git clone https://github.com/NVTaranets/Pytest-BDD.git
```
Создать виртуальное окружение
```
py -m pip install --upgrade pip
```
Установить зависимости
```
pip install -r requirements.txt
```

# # # Выполнение тестов
Тесты легко запускать, так как в проекте используется Pytest, поэтому выполнение тестов так же просто, как и выполнение Pytest. Тесты для отдельной страницы могут быть запущены путем передачи соответствующего файла шагов в качестве параметра команде, например, для выполнения только тестов страницы yandex 'pytest .\step _ defs\test_home_page_steps.py'. Обратите внимание, что указан файл шагов, а не файл элементов. Файл шагов привязывается к соответствующему элементу с помощью ключевого слова «scriptions» в файле шагов, при этом путь к файлу элементов передается в качестве параметра. Свойство «browser» также может быть указано в командной строке, например, «pytest --browser Firefox» запустит набор тестов в Firefox.
Для возможности увидеть вывод данных из пунктов h и l задания запустить 'pytest -s'


# # # ПРИМЕЧАНИЕ
Каждый тест открывается в отдельном экземпляре браузера (который закрыт в конце теста), поэтому не самый быстрый способ запуска набора тестов, но это правильный способ, так как мы должны гарантировать, что тесты полностью независимы друг от друга, не имеют общего состояния и могут выполняться в любом порядке. Нет зацепов «BeforeAll» и «AfterAll» (о которых мне известно), поэтому мы не можем открыть один браузер в начале набора тестов, перейти на соответствующую страницу в настройках для каждого отдельного сценария тестов и закрыть браузер в конце набора тестов. Наличие отдельного браузера для каждого теста также позволяет проводить параллелизацию теста, которая в противном случае была бы невозможна.


### Авторы
Таранец Николай

## License

MIT

**Free Software, Hell Yeah!**